### 링크

https://level.goorm.io/l/challenge/goormthon-challenge

### 문제

문제, 입력, 출력은 긁어오기 힘드므로 링크 참고

### 입력

생략

### 출력

생략

### 접근 방법

#### 문제 재정의

N 만큼의 통증이 있고 이 통증을 A,B 라는 아이템으로 0 까지 줄여줘야 한다.단, 0으로 만들어야지, 0을 넘어 음수가 되면 안된다. A,B가 각각 얼만큼 통증을 줄여주는 지는 사용자의 입력에 달렸지만, B가 A보다 작고, A와 B는 배수 관계가 아니라는 힌트가 있다. 이 힌트를 통해 사용자의 통증을 0까지 줄여주려면 최소 몇개의 아이템을 사용해야하는지 출력하라.

#### 전략

1. 이전에 풀었던 통증 문제와 비슷하지만 다르다. 통증을 줄여주는 아이템들의 통증을 줄여주는 **정도가 '배수' 관계가 아니라는 점이다. '배수'관계가 아니라는 점의 중요한 포인트는 뭐냐. 단순히 N // B, (N % B) // A 한다고 해서 답이 나오는 게 아니라는 뜻이다.** 그런데 어라. 나는 예전에 이 문제와 비슷한 문제를 풀어 본 기억이 있다. 바로 설탕 배달 문제였다. 해당 문제도 이 문제와 비슷한 상황을 가정하고 있으니, 해당 문제에 적용했던 알고리즘을 그대로 써먹을 수 있을 것 같다.

#### 계획 검증

1에 대한 검증 -> 이 알고리즘의 시간 복잡도를 좌우하는 것은 반복문의 횟수인데, 반목문은 N // B 만큼 돌게되어있으므로, 시간 초과는 나지 않을 것 같다.

#### 구현

```
def solution():
	N = int(input())
	A,B = map(int, input().split())

	item_count = N // B


	while item_count >= 0:
		remain_ache = N - item_count * B

		if remain_ache % A == 0:
			item_count += remain_ache // A
			print(item_count)
			break

		item_count -= 1

	if item_count < 0:
		print(-1)

solution()

```

#### 트러블 슈팅

8월 29일자 오늘 나온 답지를 보니, 동적계획법으로도 풀 수 있다는 것을 깨달았다.

~~사실 동적계획법으로 풀려고 시도하긴 했었는데 점화식을 만들지 못했다~~

https://goorm.notion.site/2-Python3-dbb4f6f133344584b317c1ee60a697cb

dp[i] 는 통증 수치가 i 일때, 이 통증 수치를 0으로 만들기 위하여 필요한 최소 아이템의 수라고 정의를 했다.

따라서 dp[0]은 0이고 이후의 숫자부터, dp[i] = dp[i - A] + 1, dp[i] = dp[i - B] + 1 이라는 식을 세우게 된다. dp[i - A]는 통증이 i - A 일때, 이 통증 수치를 0으로 만들기 위하여 필요한 최소 아이템의 수이며, 여기서 통증 수치가 i일때의 경우를 구하려면 A 아이템을 한번 더 써야 한다. 따라서 dp[i - A] + 1이 되는 것이다. B의 경우도 마찬가지다.

(i - A >= 0 인 경우에 대해서만 계산을 하는 것은 당연하다. 그렇지 않으면 index out of range 에러가 날테니...)

이 두가지 경우에 대해서 min 값을 찾으며 for loop를 돌다보면 i에 대해서 A,B 아이템을 얼마씩 써야하는지가 배열에 결과로 드러나게 된다.

### 코드

생략

### 마치며

생략
