---
title: "BOJ 1003 풀이"
description: "BOJ 1003 문제는 어떻게 풀면 좋을까?"
date: "2023-07-30"
category: "BOJ"
thumbnail: "boj_thumbnail.png"
---

### 링크

https://www.acmicpc.net/problem/1003

### 문제

.
.
.
자세한 건 링크 참고
.
.
fibonacci(3)을 호출하면 다음과 같은 일이 일어난다.

fibonacci(3)은 fibonacci(2)와 fibonacci(1) (첫 번째 호출)을 호출한다.
fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다.
두 번째 호출한 fibonacci(1)은 1을 출력하고 1을 리턴한다.
fibonacci(0)은 0을 출력하고, 0을 리턴한다.
fibonacci(2)는 fibonacci(1)과 fibonacci(0)의 결과를 얻고, 1을 리턴한다.
첫 번째 호출한 fibonacci(1)은 1을 출력하고, 1을 리턴한다.
fibonacci(3)은 fibonacci(2)와 fibonacci(1)의 결과를 얻고, 2를 리턴한다.
1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다.

각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.

### 출력

각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.

### 접근 방법

#### 문제 재정의

피보나치 수열의 N번째 수를 구하는 알고리즘이 있다. (링크 참고) 각 테스트 케이스에 대해 피보나치 수열의 N번째 수를 구하는 알고리즘을 전개할 때, 1과 0이 총 몇번 출력되는지 공백으로 구분해서 출력하라.

- 피보나치 수열이라함은, 1,1,2,3,5 순으로 전개되는 수열이다.

#### 전략

1. fibonacci(2)는 결국 1 1개, 0 1개를 출력하고 fibonacci(3)은 결국 1 2개, 0 1개를 출력한다. 이런 식으로 생각을 하다보면 fibonacci(4)는 1 3개, 0 2개를 출력하고 fibonacci(5)는 1 5개 0 3개, fibonacci(6)은 1 8개, 0 5개를 출력하게 된다. 피보나치 수열의 N번째 수를 구하는 것 자체는 관심사가 아니므로, 일단 N 크기의 배열에 배열[0]에는 0의 개수 1개, 1의 개수 0개를 뜻하는 [1,0]을 저장하고 배열[1]에는 [0,1]을 저장한다. 그리고 배열[2] 부터는 배열[index -1][0] + 배열[index -2][0] 그리고 배열[index - 1][1] + 배열[index - 2][1]을 더해서 저장한다. 그리고 최종적으로 배열[N]을 출력하면 된다.

#### 계획 검증

1에 대한 검증 -> 연산의 횟수가 어느 정도쯤 될까. 배열[2]부터 배열[N]까지 계산을 하게 되므로 약 O(N)쯤 될것으로 예상한다. N은 최대 40이므로 시간 초과는 나지 않을 것으로 예상한다. 메모리는 얼마쯤 차지할까. N개 크기의 배열에 대해 숫자 2개를 저장하고 있는 배열이 있으므로 실질적으로 40 \* (28+28) = 2240바이트 정도로 예상한다. 메모리 초과도 나지 않을 듯하다. 테스트 케이스가 몇 개냐에 따라 조금 달라지겠지만...

#### 구현

```


def solution():
  T = int(input())

  for _ in range(T):
    N = int(input())

    if N == 0:
      print(" ".join(str(el) for el in [1,0]))
      continue

    fibonacci = [[0,0] for _ in range(N+1) ]
    fibonacci[0] = [1,0]
    fibonacci[1] = [0,1]


    for index in range(2, N+1):
      fibonacci[index] = [fibonacci[index-1][0]+fibonacci[index-2][0], fibonacci[index-1][1] + fibonacci[index-2][1]]

    print(" ".join(str(el) for el in fibonacci[N]))


solution()
```

#### 트러블 슈팅

나의 방법도 나쁘지 않다고 생각하지만 다른 사람은 어떻게 풀었는지 탐구했다. 나와 비슷한 방법으로 풀긴 했지만 접근이 조금 달랐다. 바로, 더욱 분명한 '규칙'을 사용하는 것이다. 배열[0], 배열[1]을 제외한 배열[2]부터는 무조건 배열[index][0]의 값은 배열[index - 1][1]이고, 배열[index][1]의 값은 sum(배열[index - 1])라는 규칙이 있었던 것이다. 거의 맞게 풀었는데 규칙을 발견하지 못해서 아쉽다.

### 코드

생략

### 마치며

그래도 나는 알고리즘 문제 풀기 연습하기 전이었다면 결코 풀어내지 못했을 문제를 손쉽게 풀었다는 것에 만족한다. 다만, '규칙을 찾아보자'는 새로운 방식의 시각을 찾게되어 기쁘다.
